## ALGORITHM

#### 슈더코드

#### 좋은 알고리즘

- 정확성
- 작업량
- 메모리 사용량
- 단순성
- 최적성



#### 시간 복잡도= 빅-오 표기법(최악의 경우를 따진다)

1. 입력에 따라서 변하지 않는 것들은 생략
2. 가장 높은 차수만 남김
3. 계수를 제거한다.



#### 배열

- 1차원 리스트 입력 A=list(map(int,input().split()))
- 1번 인덱스 부터 넣고 싶으면 A=[0]+list()

gravity?

#### 정렬

##### 버블 정렬

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 시간 복잡도 O(n^2)
- 정렬할 구간을 정함->정렬히면서 구간이 줄어듬-> 두개 남을 때까지



선형시간 --> O(n)

##### 카운팅 정렬

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능!
- 시간 복잡도 O(n+k): n은 리스트 길이 k는 정수의 최대값
- 각각의 값인 인덱스로 가서 +1 해줌
- data 원소의 범위가 카운트 배역 개수로

##### Baby-gin Game

##### 완전검색=Brute-force,generate-and-test

- 모든 경우의 수를 나열해보고 확인하는 방법

##### 순열

##### 탐욕 알고리즘

1. 해 선택
2. 실행 가능성 검사
3. 해 검사

- 거스름돈 줄이기

  



